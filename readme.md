
[![Twitter URL](https://img.shields.io/twitter/url/https/twitter.com/bukotsunikki.svg?style=social&label=Follow%20%40jyoung424242)](https://twitter.com/jyoung424242)

<h1 align="center">Tutorial for Hathora Back End/Peasy-UI Front End</h1>

# :wave: Introduction to the tutorial

This tutorial was penned to provide a simple example of how the Hathora framework can be utilized to quickly create a multiplayer backend game server.  With that, this tutorial showcases Peasy-UI framework to create a custom UI for the clients to connect to that server.  The game being created for this example is a simple Pong game.  This tutorial uses a state machine, simple physics and collision detection/resolution, and game state.  The game state will be bound to UI components via Peasy-UI.

## :clipboard: Table of Contents (Links)

-   [Introduction](#ðŸ‘‹-introduction-to-the-tutorial)
-   [End State Objective](#end-objective)
-   [Tools](#tools)
-   [Hathora](#hathora-backend)
-   [Where to Find](#where-to-find)
-   [Workflow](#workflow)
-   [Project Folder Setup](#project-setup)
-   [Hathora YML](#yml)
-   [Hathora Init](#generating-hathora-project)
-   [IMPL.ts file](#implts)
-   [Prototype UI client](#prototype-test-client)
-   [Filling in Server Logic](#filling-in-the-rest-of-the-server-logic)
-   [Internal State](#internalstate)
-   [Initialization](#initialize-autogenerated)
-   [Join Game](#joingame)
-   [Start Game](#startgame)
-   [Start Round](#startround)
-   [UpdatePlayerPosition](#updateplayerposition)
-   [getUserState](#getuserstate)
-   [onTick](#ontick)
-   [Custom UI](#custom-ui)

## :trophy: End Objective

The end state for this tutorial is a deployed client on Netlify that runs the client code that connects to the Hathora backend server.   It takes two players who can join the game, and each player has three lives.  The ball bounces around until it leaves the screen on either side, and that player loses a life each time.  When all the lives are gone, the game ends. 

## Tools
### Hathora
Hathora is a multiplayer networking framework that manages much of the low-level duties that otherwise would have to be managed.  Use cases for Hathora include turn-based games, real-time multiplayer games, and social applications such as chatting.  Hathora manages the networking and remote procedure calls, provides a prototyping UI client, and provides a full API that abstracts away much of the low-level work.
### Peasy-UI
Peasy-UI is a UI data binding Library. Peasy UI provides uncomplicated UI bindings for HTML via string templating. It's intended to be used in vanilla JavaScript/Typescript projects where using â€˜createElementâ€˜ is too cumbersome and adding a complete SPA framework is overkill or simply not desired. Thanks to the small scope of the library, performance is decent.

### Development Environment
I developed this project and tutorial on a Windows 10 system, utilizing VS code, and executing all terminal commands in the node PowerShell terminal embedded in VS code.  There maybe be nuanced differences between developing on a Mac or Linux system.  Also, if using different shell applications or a different IDE, there may be subtle differences to take note of.

## Hathora Backend
### Where to find:
#### GitHub
- [Hathora Github](https://github.com/hathora/hathora)

There is a comprehensive readme file that helps get you started, which this tutorial essentially holds your hand through.

#### Documentation
- [API documentation for Hathora](https://docs.hathora.dev/#/)

The API documentation for Hathora can be found here, which is a very nice, continually updated, site that outlines everything you need to know about using this framework.

#### Discord
- [Hathora Disord](https://discord.gg/3MuAdAdb)

The Hathora discord server gives you access to the team directly.  This has been critical for me and my journey with Hathora, as the team has proven very open to ideas, very responsive to any issues encountered, and overall is a great group of individuals that Iâ€™ve enjoyed interacting with.  I get updates on new features and guidance on any API breaking changes here as well, which is a plus.

## Workflow

This is the true beginning of the tutorial, and we will start with the backend server using Hathora first.

### Project Setup
![Empty Project](/tutorial/screenshots/ss1.png)


#### Initial Project Folder

First, letâ€™s start with a blank project.   I will be using VS code editor for this tutorial.  We will create a new folder; I am calling mine Pong HathoraPeasy.  This tutorial also assumes you have node.js installed.  If you donâ€™t, you can go to https://nodejs.org/ and download and install node.js.
Open the terminal window in the editor, CTRL + J, will work as the shortcut. Here I will type:

```bash
npm install -g hathora
```
 
This will install the Hathora NPM package from the internet.  After that installation is complete, we will create a new file, hathora.yml, in the root of our new project folder.
 
#### YML

The hathora.yml is a critically important file.  A â€œyamlâ€ file is a human-readable data-serialization language. 

According to Wikipedia:  

```
It is commonly used for configuration files and in applications where data is being stored or transmitted. 

YAML targets many of the same communications applications as Extensible Markup Language (XML)â€¦
```

Before Hathora, I didnâ€™t know what a YML file was, soâ€¦ this was all new to me.
We must outline out what our YML file needs to look like before we ask Hathora to build the project structure.  Hathora parses the YML file, and builds the backend server template, the prototype UI, and provides the end path for your custom front end client when it builds the project.
There are several sections that we need to cover in hathora.yml: types, methods,  auth, userState, and error.
 
These sections will have to be addressed prior to asking Hathora to parse it.

![Beginning YML file](/tutorial/screenshots/ss2.png)

Types (from the docs)

![Types Docs](/tutorial/screenshots/ss3.png)

Methods (from the docs)

![Methods Docs](/tutorial/screenshots/ss4.png)

Auth (from the docs)

![Authentication Docs](/tutorial/screenshots/ss5.png)
 
userState (from the docs)
 
![userState Docs](/tutorial/screenshots/ss6.png)
 
initializeArgs (from the docs) â€“ for this tutorial we will not be using this
 
![initializeArgs Docs](/tutorial/screenshots/ss7.png)
 
Error (from the docs)
 
![Error Docs](/tutorial/screenshots/ss8.png)
 
Tick (from the docs)
 
![Tick Docs](/tutorial/screenshots/ss9.png)
 
Soâ€¦ given that information, Iâ€™m outlining that our hathora.yml will be defined initially as follows:

```yml
types:
    GameStates:
        - Idle
        - PlayersJoining
        - WaitingToStartGame
        - WaitingToStartRound
        - InProgress
        - GameOver
    Vector:
        x: float
        y: float
    Ball:
        position: Vector
        velocity: Vector
        radius: int
        isColliding: boolean
    Player:
        id: UserId
        lives: int
        position: Vector
        size: Vector
        velocity: Vector
        isColliding: boolean
    PlayerState:
        player1position: Vector
        player2position: Vector
        ballposition: Vector
        player1Lives: int
        player2Lives: int

methods:
    updatePlayerVelocity:
        velocity: Vector
    startRound:
    joinGame:
    startGame:

auth:
    anonymous: {}

userState: PlayerState

error: string

tick: 50

```
 
Letâ€™s step through the â€˜whyâ€™ on this.  Under types, were outlining several types that we want the server to manage: Vector, Ball, Player, Game States,and Player State.  

GameStates is a type that lets us use a simple state condition to track our progress through the server, we will use this to create â€˜guardâ€™ conditions so we can ensure random procedure calls only are listened to at the right time

Vector is a type that will have an (x,y) as integers being tracked.  This will be used for the Ball entity type that weâ€™ve outlined, as a ball type will have a vector signifying its position and velocity.  

Also on the Ball type, we define a radius integer, which will be used for collision detection.  The position and velocity are used for managing the movement of the ball, and there is a flag isColliding for collision detection.

Player type will outline all the characteristics of each player that connects, including an id, the number of lives remaining, and the position of the players paddle on the screen.  Also velocity for each player will be managed as well as the isColliding flag

The Player State type is important, as we separate the collective state that the server monitors from what data is broadcast to each client on change.  So, each client will understand and be able to monitor changes in the ballsâ€™ entities, and the playersâ€™ entities.  When the Server state data changes, the data gets remapped into Player State prior to being pushed to clients.  The reason we seperate the overall Server state from the Player state is that there ususually is data that the Server monitors for state changes that we don't want each client to see.  A good example is a game of Poker;  the server needs to monitor ALL the players hands, but only needs to broadcast to each client their respective hand data.  This took me awhile to understand, but there's two aspects to this, we should ONLY send he minimum amount of data to the client that it needs to operate, and we shouldn't burden the client with data that should be hidden, and then expect the client code to do the sorting.

There are four methods weâ€™re defining for this, updatePlayerPosition, joinGame, startRound and startGame.

These will generate remote procedure calls for the clients to execute and communicate events to the server.

We are setting our authentication to anonymous for this tutorial, and we are defining a tick event that will run every 50 milliseconds.

### Generating Hathora Project

Letâ€™s try generating our Hathora project off this YAML.   In the PowerShell terminal, enter:
 
 ```bash
 hathora init
 ```

Now your project in the explorer should look a bit like this:

![Hathora Project Structure](/tutorial/screenshots/ss10.png)
 
As you can see, Hathora has generated our project structure for us.  It includes all the API libraries automatically, as well as created  our server directories and our client directories.
A .gitignore is also initially included so you can create a repo at this time if you would like.  For your reference, mine is at 

- [Tutorial GitHub Link](http://github.com/jyoung4242/Pong-HathoraPeasy)

### IMPL.ts

Now weâ€™re ready to start looking at our server backend code.  Under the server directory youâ€™ll find you implementation file, impl.ts.

![Imple.ts](/tutorial/screenshots/ss11.png)
 
This is the main code that is used for your server.  You can import and include other modules here too, if you want to break up your code, which we will do for this tutorial.  Also generated is the prototype test client which we will look at next.

### Prototype Test Client

Iâ€™m now going to introduce you to the prototype UI client tool which is provided by Hathora.  We can use this tool to quickly iterate over the server logic in the impl.ts file.  This section will show the UI and its interface but know that we will be using it to fill out the server code.
From the PowerShell terminal, type: 
 
```bash
hathora dev
```

Congratulations, you have a client/server setup running!  Yay!

This will launch the prototype UI tool, built into Hathora, which allows you to quickly mockup your server methods.  It also launches the server so that the prototype UI can connect to it and test it.  

The client UI is running at http://localhost:3000/.  You may need to open your default browser and navigate to this URL directly.  It is automatically connecting to your server running out of VS code, and will look like this:
 
![ProtoType UI](/tutorial/screenshots/ss12.png)

You will see the authentication login button has anonymous set in the text, this is because of our auth setting in the hathora.yml file.

If you click the login button, you will find something like this:

![UI Logged In](/tutorial/screenshots/ss13.png)

You will notice in the top right, that Hathora, as an anonymous login, will assign you a random user ID, in this case its miniature-violet-tahr.  This changes every time you login, anonymously.  The UI gives you a few options here, you can create a new game instance, join and existing game, or use Hathoraâ€™s built in matchmaking functionality, which we will not get into during this tutorial.

Click the Create New button.  The prototype UI client should now look like this:
 
![UI Logged In](/tutorial/screenshots/ss14.png)

You get a view of the client state thatâ€™s pushed down to each client, and a button that gives  you access to the defined methods from hathora.yml.  Clicking the â€˜methodsâ€™ button will expand a list of available remote procedure calls, â€˜methodsâ€™ that you can send to the server, with the necessary data fields:

![UI Game Created](/tutorial/screenshots/ss15.png)

This is how youâ€™re going to rapidly create your server logic and test it iteratively 

IMPORTANT NOTE: if you are updating your logic, youâ€™ll have to close the server, save your updates, and restart it so it compiles your changes.  I recommend using 

```bash
hathora start
```

To compile and run any updatesâ€¦.  

Just as an example, you can put a console.log() in your impl.ts file and recompile your server.

```ts
console.log(`UpdatePlayerPosition has been clicked with ${request.yPosition}, passed by ${userID}`);
```

And then click the updatePlayerPosition button with some data in it and see what happens in your server console.
 
![console shot](/tutorial/screenshots/ss16.png)

This demonstrates how these methods get called, and how you have access to the data objects being passed from each client.

#### Filling in the rest of the server logic

Back into the impl.ts file, if you review the Impl class thatâ€™s created by Hathora, you can see there are pre-generated methods available, some of which, we specified in our hathora.yml file.  The others are autogenerated and we will discuss each now.

#### InternalState:  

```ts
type InternalState = {
    Players: Player[],
    Balls: Ball[],
    gameState: GameStates,
}
```

This designates the object that the server will monitor for changes.  This doesnâ€™t have to be what is sent to each client on changes, however.  As you will see, we are going to modify a couple things here.  Lets change it from PlayerState to ServerState.  Later on, this will force us to remap the ServerState to the PlayerState prior to pushing to clients.
 
#### Initialize:  autogenerated

```ts
initialize(ctx: Context, request: IInitializeRequest): InternalState {
        return {
            Players: [],
            Balls: [],
            gameState: GameStates.PlayersJoining,
        };
    }
```

This letâ€™s you define the default values for player state on the creation of a game instance.  If you recall, we defined ServerState as follows: 
 
#### joinGame:

```ts
joinGame(state: InternalState, userId: string, ctx: Context, request: IJoinGameRequest): Response {
        if (state.gameState != GameStates.PlayersJoining) return Response.error('Cannot allow players to join');
        if (state.Players.length >= 2) return Response.error('This game has maximum amount of players');
        let startingposition: number;

        if (state.Players.length == 1) startingposition = secondPlayerX;
        else startingposition = firstPlayerX;

        state.Players.push({
            id: userId,
            lives: 3,
            velocity: { x: 0, y: 0 },
            position: { x: startingposition, y: 0 },
            size: { x: 10, y: 48 },
            isColliding: false,
        });

        if (state.Players.length == 2) {
            state.gameState = GameStates.WaitingToStartGame;
            ctx.broadcastEvent('P2');
        } else if (state.Players.length == 1) {
            ctx.broadcastEvent('P1');
        }
        return Response.ok();
    }
```

The joinGame method primary job is to add the Player object to the array of state.Players array.  Depending on the length of the array, you position it on the left or right.  Also, if the 2nd player is joined, we modify game state to be ready to start the game.
 
#### startGame:

```ts
startGame(state: InternalState, userId: string, ctx: Context, request: IStartGameRequest): Response {
    if (state.Players.length != 2) return Response.error('Invalid number of players');
    if (state.gameState != GameStates.WaitingToStartGame) return Response.error('Not ready to start game');

    //create first ball
    const startPosition = { x: state.Players[0].position.x + 12, y: state.Players[0].position.y + 12 };
    state.Balls.push({
        position: startPosition,
        velocity: { x: 0, y: 0 },
        radius: 15,
        isColliding: false,
    });

    //update Gamestate
    state.gameState = GameStates.WaitingToStartRound;
    ctx.broadcastEvent('Ball');
    return Response.ok();
}
```

The startGame method primary function is to modify the game state after we add a ball into the game.  The ball is automatically added next to the left playerâ€™s paddle.
 
#### startRound:

```ts
startRound(state: InternalState, userId: string, ctx: Context, request: IStartRoundRequest): Response {
    //gaurd conditions
    if (state.gameState != GameStates.WaitingToStartRound) return Response.error('Cannot start round');

    //set starting angle, by which side your on
    //if left side, angle will be between
    let startingAngle: number;
    if (state.Balls[0].position.x < 300) startingAngle = ctx.chance.integer({ min: -75, max: 75 });
    else startingAngle = ctx.chance.integer({ min: 115, max: 255 });
    let magnitude: number = ballSpeed;

    let xComponent = magnitude * Math.cos(toRads(startingAngle));
    let yComponent = magnitude * Math.sin(toRads(startingAngle));
    state.Balls[0].velocity = { x: xComponent, y: yComponent };
    state.gameState = GameStates.InProgress;
    return Response.ok();
}
```

The startRound method primary job is to set the initial velocity of the ball off the left playerâ€™s paddle, and to modify the game state to an active state.
 
#### updatePlayerPosition:

```ts
updatePlayerVelocity(state: InternalState, userId: string, ctx: Context, request: IUpdatePlayerVelocityRequest): Response {
    if (state.gameState != GameStates.InProgress && state.gameState != GameStates.WaitingToStartRound && state.gameState != GameStates.WaitingToStartGame) return Response.error('Cannot update velocity');

    let pIndex = 0;
    if (state.Players[1]) {
        if (userId == state.Players[1].id) pIndex = 1;
    }

    state.Players[pIndex].velocity = request.velocity;
    return Response.ok();
}
```

the updatePlayerPosition method will take the velocity vector from the client and update the global state.  
 
#### getUserState:
```ts
getUserState(state: InternalState, userId: UserId): PlayerState {
    let clientState: PlayerState = {
        player1position: state.Players[0] ? state.Players[0].position : { x: 15, y: 10 },
        player2position: state.Players[1] ? state.Players[1].position : { x: 575, y: 10 },
        ballposition: state.Balls[0] ? state.Balls[0].position : { x: 25, y: 25 },
        player1Lives: state.Players[0] ? state.Players[0].lives : 3,
        player2Lives: state.Players[1] ? state.Players[1].lives : 3,
    };

    return clientState;
}
```

getUserState is an automatically generated method from Hathora, that allows the server to modify the returned state to the client based off the userIDâ€¦. For example, in a card game where you donâ€™t want each client to know the card values of all the players, you can filter the provided client state so that you donâ€™t expose that data to each client.  This is how we will re-map player state, take note of using the ternary operator to set a default for undefined data:
 
#### onTick:

The onTick method will be the engine that runs the game.  We have it set to a 50ms tick routine that runs when the game is started.   It has several jobs in this game, and we will break them down.

##### Updating player paddle position

```ts
//player movement
for (const player of state.Players) {
    //check for players being at 'top' and 'bottom of screen
    const hittingTop = player.position.y < 0;
    const hittingBottom = player.position.y + player.size.y >= screenHeight;

    const pixelsToMove = paddlespeed * timeDelta;
    if (!hittingTop && player.velocity.y < 0) {
        player.position.y += player.velocity.y * pixelsToMove;
    } else if (!hittingBottom && player.velocity.y > 0) {
        player.position.y += player.velocity.y * pixelsToMove;
    }
    if (state.gameState == GameStates.WaitingToStartRound) {
        if (state.Balls[0].position.x < 300) {
            //left player
            if (player.id == state.Players[0].id) state.Balls[0].position.y += state.Players[0].velocity.y * pixelsToMove;
        } else {
            //right player
            if (player.id == state.Players[1].id) state.Balls[0].position.y += state.Players[1].velocity.y * pixelsToMove;
        }
    }
}
```

Based on the velocity vectors provided by each client, we will move the player paddles up or down, unless they hit the top/bottom of the screen.  Also, as a note, if we are waiting to start the next round, the ball will move up/down with the paddles.
 
#### Ball physics:

##### Ball movement:

Based on the ball velocity vector, we reposition the ball for each tickâ€¦

```ts
//set each ball movement
for (const ball of state.Balls) {
    if (ball.velocity.x >= 0) ball.position.x += (ball.velocity.x + ballspeedAdjustment) * timeDelta;
    else ball.position.x += (ball.velocity.x - ballspeedAdjustment) * timeDelta;
    if (ball.velocity.y >= 0) ball.position.y += (ball.velocity.y + ballspeedAdjustment) * timeDelta;
    else ball.position.y += (ball.velocity.y - ballspeedAdjustment) * timeDelta;
}
```
 
##### Ball collision with player:

This block of code runs a helper routine that detects overlap between balls and player paddles, and setâ€™s each entityâ€™s isColliding property.  If a ball is hitting, we change its velocity to send it back the other direction.  The helper routine changeVelocity takes care of that.

```ts
//check for collisions with players
detectCollisions(state);

for (const player of state.Players) {
    if (player.isColliding) {
        vollies += 1;
        for (const ball of state.Balls) {
            if (ball.isColliding) {
                //depending on player, change balls velocity accordingly
                changeVelocity(ball, player);
            }
        }
    }
}
```

##### Ball collisions with top/bottom of screen:

This Block performs similar evaluation, checks for collision with top and bottom of screen, and depending on that changes the velocity of the ball to send it the opposite direction.

```ts
//check for balls being at 'top' and 'bottom of screen
for (const ball of state.Balls) {
    const hittingTop = ball.position.y <= 0;
    const hittingBottom = ball.position.y + ball.radius >= screenHeight;
    if (hittingTop) {
        //updateVelocity
        vollies += 1;
        changeVelocity(ball, 'top');
    } else if (hittingBottom) {
        //updateVelocity
        vollies += 1;
        changeVelocity(ball, 'bottom');
    }
}
```
##### Ball collisions with left/right of screen:

This Block performs similar evaluation, checks for collision with left and right of screen, and depending on that repositions the ball back on the player paddle and resets the round.  Also, lives data is updated.

```ts
//check for ball leaving screen on left/right
for (const ball of state.Balls) {
    const hittingLeft = ball.position.x <= 0;
    const hittingRight = ball.position.x + ball.radius >= screenWidth;
    if (hittingLeft) {
        //player left decrement lives
        state.Players[0].lives -= 1;
        //if lives 0, game over
        if (state.Players[0].lives == 0) {
            ctx.broadcastEvent('Game Over');
            state.gameState = GameStates.GameOver;
        } else resetGame(state, 'left');
    } else if (hittingRight) {
        //player right decrement lives
        state.Players[1].lives -= 1;
        if (state.Players[1].lives == 0) {
            ctx.broadcastEvent('Game Over');
            state.gameState = GameStates.GameOver;
        } else resetGame(state, 'right');
    }
}
```

Final look at prototype UI
When you open two clients, login, joinGame, then startGame, you will see this:

![Proto UI Complete](/tutorial/screenshots/ss17.png)

As you can see in both client instances, they are separately logged in as two different idâ€™s.  But you can see both users in the â€˜stateâ€™ data that is being pushed down to each client.  

If the RPC (remote procedure call) is fired off to start the round, you will start seeing the onTick method updating the ball position, and the velocity will update if the ball collides with a wall or paddle.  If the ball hits the edges of the screen, the position of the ball will be reset, and the game state will change.

## Custom UI

Soâ€¦ now in theory, our backend server code is done.  And we can exercise it with our prototype UI code, but what if we want to create our own custom front end UI that does this?  Letâ€™s start looking into that now.
Peasy-UI Front End
Why Peasy-UI?
I chose to use Peasy-UI for a few reasons.   I liked that its pure Typescript, and that I can bundle it down to an html file and a JS file.  Easy to deploy, as there are no complicated build steps required to generate it, as we are simply using the webpack bundler.  It also doesnâ€™t have as much overhead as say Angular, React, or other SPA frameworks.
Also, it provides a really clean way of abstracting UI code from the business logic and creates a bit of separation in the codebase.
Where to find
GitHub https://github.com/peasy-ui/peasy-ui
NPM: https://www.npmjs.com/package/peasy-ui

Data Bindings
The data bindings work through the string templating code.  We will provide the library a string template of the HTML directly and embed that template with â€˜bindingsâ€™ that will be parsed out and monitored for change of state.
For Peasy-UI to work, you must pass the library a template and a data model object, or â€˜stateâ€™.   The template will make references to the state object passed, and that is what you modify to update your UI.  A very quick example to outline this:
 
The template string being used has two input radio buttons.  You can see a data binding on the color property of the model object, and a binding on the onChange event of the radio button.
In this binding patter, the radio button sends the radio button value attribute of either â€˜redâ€™ or â€˜greenâ€™ to the color property when active.  When the onChange event is fired, you see the method changedColor() is ran.
This is just a small slice of the binding patters. Here is an outline of the available patterns from the Peasy-UI readme.
${attr <== prop}    Binding from model property to element attribute
${attr <=| prop}    One-time binding from model property to element attribute
${attr ==> prop}    Binding from element attribute to model property
${attr <=> prop}    Two-way binding between element attribute and model property

${prop}             Binding from model property to attribute or text
${|prop}            One-time binding from model property to attribute or text

${event @=> method} Event binding from element attribute to model method

${'value' ==> prop} Binding from element to model property, used to bind values of radio buttons and select inputs to a model property

${ ==> prop}        One-time binding that stores the element in model property

${ === prop}        Binding that renders the element if model property is true
${ !== prop}        Binding that renders the element if model property is false

${alias <=* list}   Binding from model list property to view template alias for each item in the list

Custom UI overview
To simplify this as much as possible, I will create simple template.html file that renders all my index.ts code.  
I will have a login button, a create Game button and connect to Game button, and then the playing field will be available with buttons to allow for joining the game, starting the game, and keyboard bindings for updating velocity, and spacebar for starting the round.  Kind of something like this:
 
Tutorial Workflow
Creating custom UI project in Hathora framework
Step one in creating a custom UI for Hathora is to create the web directory under the Hathora client folder.
 
This folder will house the entire client project, so we can treat that as our new root directory for our client.  I use a .bat script to setup new projects, its available for you to use as well.  It can be found at:
https://github.com/jyoung4242/webpackBootstrapper
and I just place the webpack starter file (webpackstarter.bat) in the web directory and run it from the node PowerShell terminal.  Make sure you change your directory appropriately.
 
Again, this is an optional path I use as a shortcut, you are welcome to create your client project as you see fit, I donâ€™t believe it should matter with regards to the tutorial.  After I run the bat file and set it to T for typescript, my directory looks like this.
 
The batch file will automatically start up the dev server to start running the client.
We need to make sure we update our tsconfig.json and webpack.config.js files, and thereâ€™s one more support package we need.  Run this npm command in the Powershell.
 
tsconfig.json:
 

webpack.config.json
 
Installing and importing Peasy-UI
Cancel out of the dev server running, and letâ€™s install Peasy-UI.
 
Letâ€™s import Peasy-UI, open index.ts file in your client project.
 
Creating string template and data model
Now that we have access to UI, and UIView, we can define our string template and model object.
 
The string template will create several sections of the HTML elements, very simplistic, and I pass the HTML straight to the UI.create() method, with the parent element, and the data model, which for now is empty, but that will change.  The myApp parameter is defined and captured by using getElementByID for the parent div in the template HTML.
 
Peasy-UI executes its state and compare feature by calling UI.update() method.  To have this run in the background and monitor and react to changes in state, we will create a Interval to call UI.update() periodically.
 
Creating data bindings
If youâ€™re running a dev server, and using the styles.css file provided in the GitHub repo, the client should be looking like this currently:
 	
So our data binding to do list include: 
â€¢	Data Fields in the main title div, two for rendering, and two for the data
â€¢	Login button, click event binding, and one for the disabled property for the button
â€¢	Create Game and Connect game buttons, one binding each for the click event and one binding each for the disabled property
â€¢	The Game ID field data will have a data binding, and the Copy button will have an click event binding
â€¢	The Join Game and Start Game buttons will both have an click event binding and their disabled properties tied to bindings
â€¢	The Game area will have several bindings itself:
o	The fields for how many lives each player possess, will have a rendering binding and the data field will have a binding, 1 for each player
o	The player paddles will each have their rendering bindings, and their CSS transform data field bindings
o	The ball will have its own rendering binding, and its CSS transform data binding
Event bindings: ${event @=> method}
Data bindings: ${data}
Rendering bindings: ${===property}
One-way attribute binding: ${disabled<==getDisabledButton}
Two-way attribute binding: ${value<=>data}
Letâ€™s add the rest of the event bindings, we can update the code logic when ready.
 
We now have our events mocked up.  Once we connect the client to the Hathora server, weâ€™ll fill in the events will the remote procedure calls.
We can add the remaining data bindings now. Letâ€™s update the data model object:
 
Now our data bindings are complete, and now we can connect Hathora to our client.
Connecting the custom client to the server
This section is going to import the Hathora Client module, as well as fill in the logic for the Login, Create Game, and Connect Game buttons.
Letâ€™s import the Hathora Client code into our index.ts file.
 
This will give us access to the methods needed to connect our client.
Letâ€™s prepare our necessary app scoped variables :
 
This gives us the key items that are required for connecting to the back-end server.  Take note of the update state method, as we have it empty for now, we will fill it in later.
This first thing our code will do is look to see if there is a session token saved locally, in session storage.  If not, we create a new authorization token.  This I part of our Login method for the button, so letâ€™s fill that out:
 
So after a token is established with the loginAnanymous() method, we can retrieve our user data from that token.  We can set our model.username to our new ID, and the UI will automatically update, thanks Peasy!!!!
So now that weâ€™re logged in, letâ€™s work on creating a new game instance, or joining an existing one.
 
Each code is similar, the only difference being that the create game method uses the client.create() method, which allows for a gameID to be created, and yes, we tie it into our UI model, and the UI will update automatically.  The important final piece of these is the establishment of myConnection, which will be used for remote procedure calls.
Remote Procedure Calls
Using myConnection, we now have access to the methods that are created on the server, in the impl.ts file.  This lets us fill out the two other buttons, Join Game and Start Game.
 

We still need to figure out how we are going to access the updatePlayerVelocity() method.  Letâ€™s tie some keyboard presses to it.
 
This method can be called after the joinGame method is called.  This connects the last two RPCs from our server into the client.  The up and down arrows will update the players paddle velocity.  The spacebar will fire off the startRound() method.
Adding logic to the game elements
Okay, thatâ€™s quite a bit of stuff.  We have our UI bindings, the HTML framework, the RPCâ€™s, our client is connected to the server, all thatâ€™s left is now getting the information OUT of the server so our UI can use it.  This is the client state that the impl.ts file calls out.  Remember that updateState() method we defined a long time ago?  Thatâ€™s the connection for how the data is going to come out of the server when the data changes.
Tying in the server data via updateState()
Earlier we created a method call updateState() that we left empty.  Now its time to fill it out and review what is going on.
 
This routine runs whenever the server state changes, and that creates a remapping of the client state on the server side, and that state gets pushed, or broadcasted, out to each connected client.  It arrives via UpdateArgs parameter, called update, in this routine.  There are two aspects of the update object that we are going to leverage, state and events.
Update.state is the client state being pushed from the server, and we simply take the important properties of that object and store it into our data model.  The act of doing this will force Peasy-UI to respond to any changes in the data and update our UI automatically.
Update.events is the Hathora event system, and this array holds a list of the events that have been fired off from the server.  We have four events outlined in our server code, Players joining, P1 and P2, the Ball being ready to display, and Game Over.
Wrap up of test project
Weâ€™ve reviewed about 96% of the code, please refer to the project repo for the miscellaneous lines of code not reviewed, as well as the helper functions that are imported.   This completes the project at a local level, letâ€™s talk deployment.

Deployment
So how do we push our local project out to the world for others to see?  There are many, many different paths to take.
For this tutorial, I am using Netlify to push the front end out into the world, and I am self-hosting my server on a dedicated machine.  However, there are cloud-based options for deploying the backend.
Building
For the front end, I simply changed directory in /client/web/ in my project, and ran the webpack build:
 
This creates a /build/ directory under our web client.  There will be an html file and a bundled JavaScript file.  These files can be pushed to a GitHub repo project now.   We will be using our GitHub accounts to push our projects to a webhosting service, Netlify.   Many of these service providers create plugins for their tools to easily connect to GitHub repoâ€™s.  A special note for this is that the server data is being built into the client.ts and base.ts files from where you are building.  Steps should be taken to make sure the appID called out for the coordinator matches the server target.
.gitignore
I had to modify the .gitignore file so that the Hathora client dependencies can get pushed to the repot.  These files are imported into your index.ts file, so you have to give access to the hosting service.
 

Netlify -  Frontend
Please refer to the expansive amount of Netlify documentation regarding creating an account with their service.  There is a free level of service provided with Netlify.
Once your account is created you can create a new site to your account.  They have a one-click deploy feature that lets the Netlify build tools clone your GitHub repo, then package it up and launch the site live automatically.  There was a little bit of configuration in the build step to be successful.  First, I recommend changing the domain settings to a site name that makes more sense, I used Hathor-peasy-pong.netlify.app.
The final step is setting up the deployment settings.  If youâ€™ve tied your GitHub repo to this site, then you will fill out the build settings as such.  We have two static files, so there are no necessary build steps to spell out.
 
After this is setup, you can go to the deploy page for your site and trigger a deployment.  The site should go live after that.
 
Congratulations, you just made a real-life website with a multiplayer game on it!!!!
Self-Hosted Backend
To get this running on my dedicated machine at home, I simply recreated the project locally, and executed to fire up my service:
 
Now the service is running on my dedicated machine, and it can connect to the Hathora Coordinator via the internet. 
3rd party hosting service
To push to a hosting cloud service like , change your directory back to the project root.  Here youâ€™ll be able to run the Hathora build command:
 
This will run a vite script that bundles and packages up your server into a index.mjs file thatâ€™s located at /server/dist/.  This file, can be pushed to a hosting service.  From the Hathora Docs:
 
Cloud Hosting
Hathora is positioning themselves to be able to host your backend application as well.  You can have an account created with Hathora, and then use the â€˜hathora deployâ€™ command and your application will be automatically pushed to the cloud and running.  Please see the Hathora Docs and reach out to the team directly for more information.
